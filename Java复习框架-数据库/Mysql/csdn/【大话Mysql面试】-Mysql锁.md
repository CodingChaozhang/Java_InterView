## 八、锁

### 8.1 对Mysql锁了解？

**当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序**，锁机制就是这样的一个机制。

### 8.2 隔离级别与锁的关系

在Read Uncommitted级别下，**读取数据不需要加共享锁**，这样就不会跟被修改的数据上的排他锁冲突

在Read Committed级别下，**读操作需要加共享锁**，**但是在语句执行完以后释放共享锁；**

在Repeatable Read级别下，**读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。**

SERIALIZABLE 是限制性最强的隔离级别，因为该级别**锁定整个范围的键**，并一直持有锁，直到事务完成。

> 四个隔离级别
>
> 读未提交；不加共享锁；
>
> 读已提交；加共享锁，执行完语句立即释放；
>
> 可重复读；加共享锁，事务执行完毕再释放；
>
> 串行化；锁定整个范围的键，一直持有，直到事务完成；

### 8.3 按照锁的粒度划分数据库锁有哪些？

在关系型数据库中，可以**按照锁的粒度把数据库锁分**为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。

**MyISAM和InnoDB存储引擎使用的锁：**

- MyISAM采用**表级锁(table-level locking)**。
- InnoDB支持**行级锁(row-level locking)和表级锁，默认为行级锁**



**行级锁，表级锁和页级锁对比**

**行级锁** 行级锁是Mysql中锁定粒度最细的一种锁，表示**只针对当前操作的行进行加锁**。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为**共享锁** 和 **排他锁。**

特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

**表级锁** 表级锁是M**ySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁**，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为**表共享读锁（共享锁）与表独占写锁（排他锁）。**

特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。

**页级锁** 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，**一次锁定相邻的一组记录。**

特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般



**从锁的类别上来看Mysql上都有哪些锁？**

**从锁的类别上来讲**，有共享锁和排他锁。

共享锁: 又叫做读锁。 **当用户要进行数据的读取时，对数据加上共享锁**。共享锁可以同时加上多个。

排他锁: 又叫做写锁。 **当用户要进行数据的写入时，对数据加上排他锁。**排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。

用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。

> 锁的总结：
>
> 锁有行级锁，表级锁和页级锁； 每一类再分为共享锁和排他锁；

### 8.4 Mysql中InnoDB引擎的行锁是怎么实现的？

答：**InnoDB是基于索引来完成行锁**

例: select * from tab_with_index where id = 1 for update;

for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，**如果 id 不是索引键那么InnoDB将完成表锁**，并发将无从谈起

### 8.5 InnoDB存储引擎的锁的算法有哪三种？

- **Record lock：单个行记录上的锁**
- **Gap lock：间隙锁，锁定一个范围，不包括记录本身**
- **Next-key lock：record+gap 锁定一个范围，包含记录本身**

**相关知识点：**

1. innodb对于**行的查询使用next-key lock**
2. Next-locking keying为了解决Phantom Problem幻读问题
3. 当查询的索引含有唯一属性时，将next-key lock降级为record key
4. Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生
5. 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1

### 8.6 死锁是什么？怎么解决

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

常见的解决死锁的方法

- 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。 
- **在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率**；
- 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；

如果业务处理不好可以用**分布式事务锁或者使用乐观锁**

### 8.7 数据库的乐观锁和悲观锁是什么？怎么实现的？

数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。**乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。**

**悲观锁**：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制

**乐观锁**：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。

**两种锁的使用场景**

从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像**乐观锁适用于写比较少的情况下（多读场景）**，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。

但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以**一般多写的场景下用悲观锁就比较合适。**