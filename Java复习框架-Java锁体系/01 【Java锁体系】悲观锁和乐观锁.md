# 【Java锁体系】一、悲观锁和乐观锁

Java按照锁的实现分为乐观锁和悲观锁，乐观锁和悲观锁并不是一种真实存在的锁，而是一种设计思想。

## 1.悲观锁

`悲观锁`是一种悲观思想，它总认为最坏的情况可能会出现，它认为数据很可能会被其他人所修改，所以悲观锁在持有数据的时候会把`资源`或者`数据`锁住，这样其它线程想要请求这个资源的时候就会阻塞，直到等到悲观锁把资源释放为止。传统的关系型数据库里边就用到了许多这种锁机制，比如行锁、表锁等，读锁、写锁等，都是在做操作之前先上锁。

Java中的`Synchronized`个`ReentrantLock`等独占锁(排他锁)也是一种悲观锁思想的实现，因为**Synchronized**和**ReetrantLock**不管是否持有资源，它都会尝试去加锁，生怕自己心爱的宝贝被别人拿走。



## 2.乐观锁

乐观锁的思想与悲观锁的实现相反，它总认为资源和数据不会被别人修改，所以读取不会上锁，但是乐观锁在进行写入操作的时候会判断当前数据是否修改过。乐观锁的实现方案一般来说有两种：`版本号机制`和`CAS实现`，乐观锁多适用于多读的应用类型，这样可以提高吞吐量。

在Java中`java.util.concurrent.atomic`包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。



## 3.总结

`悲观锁`：认为自己在使用数据的时候一定会有别的线程来修改数据，在获取数据的时候会加锁，确保数据不会被背的线程修改；

锁实现：关键字`synchronized`，接口`Lock`的实现类

适用场景：写操作比较多，先加锁可以保证写操作时数据正确。



`乐观锁`：乐观锁认为自己的使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了数据。

锁实现：CAS算法，例如AtomicInteger类的原子自增是通过CAS自旋来实现的。

使用场景：读操作较多，不加锁的特点能够使其读操作的性能大幅度提升。



## 4.补充：Lock简介

Lock接口比同步方法和同步块提供了更具扩展性的锁操作。它们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。

其优势有：

- 可以使锁更公平；
- 可以使线程在等待锁的时候响应中断；
- 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间；
- 可以在不同的范围，以不同的顺序获取和释放锁；

整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的(tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平锁(默认)和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。